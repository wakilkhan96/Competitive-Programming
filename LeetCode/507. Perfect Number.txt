class Solution {
public:
    int divisorSum(int n) {
        int divisor, sqt, sum = 1;
        if(n&1) divisor = 3;
        else divisor = 2;
        
        sqt = sqrt(n);
        for( ; divisor<=sqt; divisor+=2) {
            if(n%divisor!=0) continue;
            if(divisor==sqrt(n)) sum += divisor;
            else {
                sum += divisor;
                sum += n/divisor;
            }
        }
        // cout<<sum<<endl;
        return sum;
    }
    bool checkPerfectNumber(int num) {
        if(num==1) return false;
        if(num==divisorSum(num)) return true;
        return false;
    }
};








Approach #1 Brute Force [Time Limit Exceeded]
Algorithm

In brute force approach, we consider every possible number to be a divisor of the given number numnum, by iterating over all the numbers lesser than numnum. Then, we add up all the factors to check if the given number satisfies the Perfect Number property. This approach obviously fails if the number numnum is very large.


Complexity Analysis

Time complexity : O(n)O(n). We iterate over all the numbers lesser than nn.

Space complexity : O(1)O(1). Constant extra space is used.

Approach #2 Better Brute Force [Time Limit Exceeded]
Algorithm

We can little optimize the brute force by breaking the loop when the value of sumsum increase the value of numnum. In that case, we can directly return falsefalse.


Complexity Analysis

Time complexity : O(n)O(n). In worst case, we iterate over all the numbers lesser than nn.

Space complexity : O(1)O(1). Constant extra space is used.

Approach #3 Optimal Solution [Accepted]
Algorithm

In this method, instead of iterating over all the integers to find the factors of numnum, we only iterate upto the \sqrt{n} 
n
​
 . The reasoning behind this can be understood as follows.

Consider the given number numnum which can have mm distinct factors, namely n_1, n_2,..., n_mn 
1
​
 ,n 
2
​
 ,...,n 
m
​
 . Now, since the number numnum is divisible by n_in 
i
​
 , it is also divisible by n_j=num/n_1n 
j
​
 =num/n 
1
​
  i.e. n_i*n_j=numn 
i
​
 ∗n 
j
​
 =num. Also, the largest number in such a pair can only be up to \sqrt{num} 
num
​
  (because \sqrt{num} \times \sqrt{num}=num 
num
​
 × 
num
​
 =num). Thus, we can get a significant reduction in the run-time by iterating only upto \sqrt{num} 
num
​
  and considering such n_in 
i
​
 's and n_jn 
j
​
 's in a single pass directly.

Further, if \sqrt{num} 
num
​
  is also a factor, we have to consider the factor only once while checking for the perfect number property.

We sum up all such factors and check if the given number is a Perfect Number or not. Another point to be observed is that while considering 1 as such a factor, numnum will also be considered as the other factor. Thus, we need to subtract numnum from the sumsum.


Complexity Analysis

Time complexity : O(\sqrt{n})O( 
n
​
 ). We iterate only over the range 1 < i ≤ \sqrt{num}.
Space complexity : O(1)O(1). Constant extra space is used.
Approach #4 Euclid-Euler Theorem [Accepted]
Algorithm

Euclid proved that 2^{p−1}(2^p − 1)2 
p−1
 (2 
p
 −1) is an even perfect number whenever 2^p − 12 
p
 −1 is prime, where pp is prime.

For example, the first four perfect numbers are generated by the formula 2^{p−1}(2^p − 1)2 
p−1
 (2 
p
 −1), with pp a prime number, as follows:

for p = 2:   21(22 − 1) = 6
for p = 3:   22(23 − 1) = 28
for p = 5:   24(25 − 1) = 496
for p = 7:   26(27 − 1) = 8128.
Prime numbers of the form 2^p − 12 
p
 −1 are known as Mersenne primes. For 2^p − 12 
p
 −1 to be prime, it is necessary that pp itself be prime. However, not all numbers of the form 2^p − 12 
p
 −1 with a prime pp are prime; for example, 2^{11} − 1 = 2047 = 23 × 892 
11
 −1=2047=23×89 is not a prime number.

You can see that for small value of pp, its related perfect number goes very high. So, we need to evaluate perfect numbers for some primes (2, 3, 5, 7, 13, 17, 19, 31)(2,3,5,7,13,17,19,31) only, as for bigger prime its perfect number will not fit in 64 bits.


Complexity Analysis

Time complexity : O(\log{n})O(logn). Number of primes will be in order \log{num}lognum.

Space complexity : O(\log{n})O(logn). Space used to store primes.